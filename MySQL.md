# MySQL

# MySQL基础篇

## （一）MySQL概述

### 一、数据库的相关概念

数据库：DataBase(DB)，是存储和管理数据的仓库。数据是有组织的进行存储的。

数据库管理系统：DataBase Management System(DBMS)，操纵和管理数据库的大型软件。**我们学习的MySQL其实本质是数据库管理系统，只不过现在开发人员为了方便，把它也称为MySQL数据库。**

SQL语言：Structured Query Language，是操作关系型数据库的编程语言。我们**通过SQL就可以操作数据库管理系统**，**然后再通过数据库管理系统操作数据库和其中的数据**。**它告诉数据库管理系统我们操作哪个数据，要进行怎样的操作**。定义了一套操作关系型数据库的**统一标注**。所有的关系型数据库都用SQL操作。

### 二、主流的关系型数据库管理系统

![image-20250919082421387](D:\Spring大礼包学习\img\image-20250919082421387.png)

### 三、MySQL数据库

#### 一、客户端连接

方式一：

![image-20250919083133683](D:\Spring大礼包学习\img\image-20250919083133683.png)

方式二：

![image-20250919083322625](D:\Spring大礼包学习\img\image-20250919083322625.png)

#### 二、MySQL数据库模型

![image-20250919083922408](D:\Spring大礼包学习\img\image-20250919083922408.png)

当我们在自己的电脑上安装了MySQL数据库后，**我们的电脑就变成了MySQL服务器**，然后我们就可以**通过客户端去连接MySQL数据库管理系统，DBMS**。然后就可以使用SQL语句，通过数据库管理系统来创建数据库。然后还可以使用SQL语句通过数据库管理系统在指定的数据库中创建表。在一个数据库服务器当中是可以创建多个数据库的。**一个数据库里面可以包含多张表，而表才是最终存储数据的。**

#### 三、关系型数据库（RDBMS）

**概念**：建立在关系模型的基础上，**由多张相互连接的二维表**组成的数据库。

特点：

1、使用表存储数据，格式统一，便于维护。

2、可以使用SQL语言操作，标准统一，使用方便。

## （二）SQL（基础篇中最重要）

### 一、SQL通用语法

![image-20250920111813174](img/image-20250920111813174.png)

### 二、SQL语言的分类

![image-20250920112314875](img/image-20250920112314875.png)

### 三、DDL

#### 一、DDL-数据库操作

1、查询数据库

查询所有数据库

```sql
show databases;
```

查询当前数据库

```sql
select database();
```

创建数据库

```sql
create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];
```

删除数据库

```SQL
drop database [if exists] 数据库名；
```

使用数据库

```sql
use 数据库名；
```

注意事项：给数据库设置字符集的时候我们不建议设置为utf8，因为utf8字符集存储的长度就是3个字节，但是数据库当中有一些特殊的字符是四个字节的，比如emoji表情，所以我们推荐使用utf8mb4。

#### 二、DDL-表操作-查询

1、查询当前数据库所有表

```sql
show tables;
```

2、查询表结构

```sql
DESC 表名;
```

3、查询指定表的建表语句

```sql
show create table 表名;
```



#### 三、DDL-表操作-创建

![image-20250922081943644](img/image-20250922081943644.png)

#### 五、DDL-表操作-数据类型

数值类型

![image-20250922083344014](img/image-20250922083344014.png)

字符串类型

**带BLOB的是用来存储二进制数据的**，**像音频、视频、软件安装包等这类数据**就是用二进制来存储的，但是在实际开发中，我们其实不这样做，因为这样做效率低下，不易管理，**我们存储音频视频这类的二进制数据一般都是存储在专门的文件服务器上的。**

![image-20250922094020377](img/image-20250922094020377.png)

char和varchar的区别

在MySQL数据库中我们在定义字符串类型时，一般会指定允许存储的最大字符数，比如char(10)、varchar(10)。char是定长字符串，也就是说如果我们指定了char(10)，那么如果存的字符串不够10个字符，那剩下的字符会用空格补足，10个字符是必须都要占满的。varchar是变长字符串，也就是说，如果我们指定了varcha(10)，如果存的字符串就3个字符，那这个字符串在内存中的实际占位也就3个字符，不会用空格补足。**相比起来，char的性能比较高一些**，因为用varchar存储时还得计算实际的字符串到底占几个字符，然后去分配对应长度的存储空间。

日期类型

![image-20250922100105774](img/image-20250922100105774.png)

#### 六、DDL-表操作-修改

**添加字段**

```sql
alter 表名 add 字段名 类型(长度) [comment 注释][约束];
```

**修改字段**

修改字段的数据类型

```sql
alter 表名 modify 字段名 新数据类型(长度);
```

修改字段名和字段类型

```sql
alter 表名 change 旧字段名 新字段名 类型(长度) [comment 注释][约束];
```

**删除字段**

```sql
alter table 表名 drop 字段名;
```

**修改表名**

```sql
alter table 表名 rename 新表名;
```



#### 七、DDL-表操作-删除

删除表

```sql
drop table [if exists] 表名;
```

删除指定表，并重新创建该表，此时之前的表连同里面的数据都会被删除，然后再重新创建一张全新的表。

```sql
truncate table 表名;
```

### 五、DML

DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增删改操作。

#### 一、DML-添加数据

1、给指定字段添加数据

```SQL
insert into 表名(字段名1, 字段名2, ...)values(值1, 值2, ...);
```

2、给全部字段添加数据

```sql
insert into 表名 values (值1, 值2, ...);
```

3、批量添加数据

```sql
insert into 表名 (字段名1, 字段名2, ...) values (值1, 值2, ...), (值1, 值2, ...), (值, 值2, ...);
```

```sql
insert into 表名 values (值1, 值2, ...), (值1, 值2, ...), (值, 值2, ...);
```

![image-20250930113952737](img/image-20250930113952737.png)

#### 二、DML-修改数据

```sql
update 表名 set 字段名=值1, 字段名=值2, ... [where 条件];
```

**注意**：修改语句的条件可以没有，如果没有条件，则会修改整张表的所有数据。

#### 三、DML-删除数据

```sql
delete from 表名 [where 条件]
```

注意：

- delete语句的条件可以没有，如果没有条件，则将删除整张表的所有数据。
- delete语句不能删除某一个字段的值，可以使用update语句将那个字段的值修改为null即可。

### 六、DQL

DQL全称是Data Query Language(数据查询语言)，用来查询数据库中表的记录。

一、DQL-语法

![image-20251009081531664](img/image-20251009081531664.png)

一、DQL-基本查询

1、查询多个字段

```sql
select 字段1, 字段2, 字段3... from 表名；
```

```sql
select * from 表名;
```

2、设置别名

为了有更好的可读性，**as其实是可以不写的**

```sql
select 字段1 [as 别名1], 字段2 [as 别名2]...from 表名;
```

3、去除重复记录

```sql
select distinct 字段列表 from 表名;
```

# MySQL进阶篇

## （二）索引

### 一、索引概述

索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级**查询**算法，从而查到实际数据。这种数据结构就是索引。

**优缺点：**

优点：

- 提高数据检索效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

缺点：

- 索引列也是要占用空间的
- 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE

### 二、索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有着不同的索引结构，主要包含以下几种：

![image-20251217161422569](img/image-20251217161422569.png)

![image-20251217170519053](img/image-20251217170519053.png)

#### 二、B-Tree

![image-20251217170753912](img/image-20251217170753912.png)

为了解决上述问题，可以使用 B-Tree 结构。
B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）

![image-20251217170833376](img/image-20251217170833376.png)

B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68
演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html

#### 三、B+Tree

![image-20251217171023877](img/image-20251217171023877.png)

与 B-Tree 的区别：

- 所有的数据都会出现在叶子节点
- 叶子节点形成一个单向链表
- 非叶子节点只是起到索引数据的作用。

#### 五、B-Tree索引

MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。每个节点都是存储在数据块当中的，也叫页。

![image-20251217172808334](img/image-20251217172808334.png)

#### 六、Hash索引

哈希索引就是采用一定的hash算法，先计算数据表中每一条记录的哈希值，再将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。
如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

![image-20251217174431315](img/image-20251217174431315.png)

**特点：**

- Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、>、<、…）
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引

哪些存储引擎支持Hash索引：

- Memory
- InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的。

#### 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？

- 二叉树，在顺序插入时会形成一个链表，查询性能大大降低，大数据量的情况下，层级较深，检索速度慢。红黑树，是一个自平衡的二叉查找树，但是大数据量的情况下，层级较深，检索速度还是会慢。
- 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。而B+Tree所有的数据都保存在叶子节点中，不管查找哪个数据都需要去叶子节点中查找，搜索效率稳定，而且在B+Tree的结构中叶子节点形成了一个双向链表，**便于范围搜索和排序**。
- Hash 索引只支持等值匹配，不支持范围匹配和排序。B+Tree 支持范围匹配及排序操作

### 三、索引分类

![image-20251217183327945](img/image-20251217183327945.png)

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

![image-20251217184746278](img/image-20251217184746278.png)

**聚集索引选取规则**：

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引
- 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引

![image-20251217183800002](img/image-20251217183800002.png)

我们要查找一条数据具体是怎么个情况：

**回表查询**：先走二级索引找到对应的主键值，再根据主键值到聚集索引中拿到这一行的行数据。

![image-20251217184436334](img/image-20251217184436334.png)

#### 面试题

1. 以下 SQL 语句，哪个执行效率高？为什么？

```sql
select * from user where id = 10;
select * from user where name = 'Arm';
-- 备注：id为主键，name字段创建的有索引
```



答：第一条语句，因为第二条需要回表查询，相当于两个步骤。

2. InnoDB 主键索引的 B+Tree 高度为多少？

答：假设一行数据大小为1k，一页的大小为16k，可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8，如果主键的类型为int则占用4个字节。

假设树的高度为2：

可得公式：`n * 8 + (n + 1) * 6 = 16 * 1024`，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170，也就意味着有1171个指针。那么他能存储的数据量大概为：`1171 * 16 = 18736`；条数据。

如果树的高度为3，那么他能存储的数据量大概为：`1171 * 1171 * 16 = 21939856`。条数据。

### 五、索引语法

**创建索引：**

```SQL
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);
```



如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引。索引是可以关联多个字段的，如果一个索引只关联一个字段，那么这种索引称为单列索引，如果一个索引关联了多个字段，我们称这种索引为联合索引或组合索引。

**查看索引**：

```sql
SHOW INDEX FROM table_name;
```



**删除索引：**

```sql
DROP INDEX index_name ON table_name;
```

### 六、SQL性能分析

对于我们做SQL优化来说，**我们主要优化的是select语句，而在优化select语句的时候呢，索引这块的优化实际上占据了主要的地位**。如果一个数据库中的数据量特别庞大，但是主要是以插入数据为主，那我们也可以不优化。所以在优化之前我们需要查一下各类SQL语句的执行频次，如果是select语句的执行频次比较高，那我们就需要优化了，如果是增删改的频次比较高，那我们的优化就可以适当放缓一些。

#### 一、查看SQL语句的执行频次

MySQL客户端连接成功后，通过show [SESSION|GLOBAL] STATUS 命令可以提供服务器状态信息，查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 执行频次：

```sql
SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______';
```

#### 二、慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。

MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：

```sql
# 开启慢查询日志开关
slow_query_log=1
# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```



更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log

查看慢查询日志开关状态：

```sql
show variables like 'slow_query_log';
```

用来查看名为 `slow_query_log` 的系统变量当前是什么值。

查看慢日志文件尾部实时输出的内容：

```
tail -f localhost-slow.log
```

#### 三、profile详情

show profile 能在做SQL优化时帮我们了解一条SQL语句的执行时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：

```SQL
SELECT @@have_profiling;
```



通过以下命令查看profiling 是否已打开：

```sql
SELECT @@profiling;
```



profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：

```sql
SET profiling = 1;
```



查看所有语句的耗时：

```sql
show profiles;
```



查看指定query_id的SQL语句各个阶段的耗时：

```sql
show profile for query query_id;
```



查看指定query_id的SQL语句CPU的使用情况

```sql
show profile cpu for query query_id;
```



#### 五、explain执行计划

前面这些判定SQL语句性能的方式都是从时间层面判定一条SQL语句的性能高低，这只能**粗略地**判断一条SQL语句的性能，**并不能真正的判断**一条SQL语句的性能。要想很好的判断一条SQL语句的性能，我们还需要借助explain来查看SQL语句的执行性能。explain在我们的SQL优化中占据着非常重要的地位，我们经常通过它来判定一条SQL语句的执行性能。它可以看到一条SQL语句的执行计划：是否用到索引，表的连接顺序都可以看到。

**语法：**

```sql
# 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```



EXPLAIN 各字段含义：

- id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）
- select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等
- **type**：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all

NULL在我们一般的业务系统中是不可能出现的，因为只有不查表的时候才会出现NULL。system 一般是查询系统表的时候会出现。根据主键或唯一索引访问会出现 const。如果使用非唯一性索引会出现ref。全表扫描时会出现all。出现index表示用了索引，但是查询时对索引进行了全扫描。

- **possible_keys**：查询的时候可能应用的索引，一个或多个
- **Key**：实际使用的索引，如果为 NULL，则没有使用索引
- **Key_len**：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
- rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的。
- filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好
- Extra：`using index condition`  或 null：查找使用了索引，但是**需要回表查询数据**。
  `using where; using index;`：查找使用了索引，但是需要的数据都在索引列中能找到，所以**不需要回表查询**

### 七、索引使用原则

#### 一、最左前缀法则

如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是**查询语句中必须有索引的最左列**，**如果跳过了最左列，索引将全部失效**，并且**不跳过索引中间的列**。如果跳跃中间某一列，**后面的字段索引失效**。查询语句中多个列的摆放顺序无关，只要包含这些列就可以。

#### 二、范围查询

联合索引中，出现范围查询（<, >），范围查询右侧的列索引失效。可以用>=或者<=来规避索引失效问题。

#### 三、索引列运行

不要在索引列上进行运算操作，**否则索引失效**。

```sql
explain select * from tb_user where substring(phone, 10, 2) = '15';
```



#### 五、字符串不加引号

字符串类型字段我们在查询的时候没有加引号，该字段的索引将会失效。

```sql
explain select * from tb_user where phone = 17799990015;
```

此处phone的值没有加引号

#### 六、模糊查询

模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；但是，但凡对头部进行了模糊匹配，那么该字段的索引失效。如：

```sql
explain select * from tb_user where profession like '%工程';
```

前后都有 % 也会失效。所以在大数据量的情况下我们应该尽量规避对头部进行模糊查询的情况。

#### 七、or连接的条件

1. 用 or 分割开的条件，如果 or 其中一个条件的字段没有索引，那么涉及的索引都不会被用到。如下：由于age没有索引，所以即使phone和id有索引，索引也会失效。所以需要给age也建一个索引。

```sql
explain select * from tb_user where id = 10 and age = 23;
explain select * from tb_user where phone = 17799990015 and age = 23;
```



#### 八、数据分布影响

在执行SQL语句的时候，如果MySQL的优化器评估使用索引比全表扫描还慢，则不使用索引。

#### 九、SQL提示

是**优化数据库**的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到**优化操作**的目的。

使用索引：这知识给数据库一个建议，建议它使用某个索引，至于这个建议数据库采纳不采纳，它还会自己评估你指定的这个索引效率到底高不高。

```sql
explain select * from tb_user use index(idx_user_pro) where profession="软件工程";
```

不要用哪个索引：

```sql
explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";
```

必须使用哪个索引：这个就不是建议了，这个是强硬手段。

```sql
explain select * from tb_user force index(idx_user_pro) where profession="软件工程";
```



#### 十、覆盖索引&回表查询

尽量使用覆盖索引（查询使用了索引，并且需要返回的字段，在该索引中已经全部能找到，不需要再回表查询了），减少 select *。

explain 中 extra 字段含义：

`using index condition`  或 null：查找使用了索引，但是**需要回表查询数据**。
`using where; using index;`：查找使用了索引，但是需要的数据都在索引列中能找到，所以**不需要回表查询**

![image-20251218160408676](img/image-20251218160408676.png)

![image-20251218160429037](img/image-20251218160429037.png)

##### 面试题：

：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：

```sql
select id, username, password from tb_user where username='itcast';
```

解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引，效率高。

#### 十一、前缀索引

当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

语法：`create index idx_xxxx on table_name(columnn(n));`

前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

求**选择性**公式：

```sql
select count(distinct email) / count(*) from tb_user;
select count(distinct substring(email, 1, 5)) / count(*) from tb_user;
```

show index 里面的sub_part可以看到接取的长度

#### 十二、单列索引与联合索引

单列索引：即一个索引只包含单个列
联合索引：即一个索引包含了多个列
在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，**建议建立联合索引**，而非单列索引。

##### 1、联合索引长啥样

如下图所示，联合索引的key值由 phone 和 name 的值共同组成，然后会先按照phone手机号进行排序，如果手机号一致再根据name字段进行排序。

![image-20251218171557265](img/image-20251218171557265.png)

### 八、索引的设计原则

1. 针对于数据量较大（一般超过100多万），且查询比较频繁的表建立索引。
2. 针对于常作为查询条件（**where**）、排序（**order by**）、分组（**group by**）操作的字段建立索引，尽量选择联合索引。
3. 尽量选择**区分度高的列**作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。**像性别啊、状态啊这种字段不适合加索引。**
4. 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，**节省存储空间**，**避免回表**，提高查询效率
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询

## （三）锁

### 一、概述

#### 一、介绍

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I/0)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

#### 二、分类

MySQL中的锁，按照锁的粒度分，分为一下三类：

1. 全局锁：锁定数据库中的所有表。
2. 表级锁：每次操作锁住整张表。
3. 行级锁：每次操作锁住对应的行数据。

### 二、全局锁

#### 一、介绍

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

**MySQL 实例**（MySQL instance）＝ 一个正在运行的 `mysqld` 服务器进程 + 它所管理的内存结构和后台线程。每个实例里可以有多个 **数据库（schema）**每个数据库里有多个 **表**。

其**典型的使用场景**是做全库的逻辑备份，对所有的表进行锁定，从而获取**一致性**视图，保证数据的**完整性**。

#### 二、基本操作

使用全局锁：`flush tables with read lock`
释放全局锁：`unlock tables`

**演示图**：

![image.png](https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51083972978.png)

![image-20251219164127612](img/image-20251219164127612.png)

mysqldump是MySQL数据库为我们提供的一个数据备份的工具，不是一条SQL语句，所以直接在命令行窗口执行就行了，不要在 >mysql 中执行。

#### 三、特点

在数据库中加全局锁，可以保证数据库备份时，数据的一致性与完整性。

数据库中加全局锁，**是一个比较重的操作**，存在以下问题:

1. 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。

1. 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟。（该结构会在后续主从复制讲解）。主从复制、读写分离是运维篇的内容。

**目前解决办法**：

在InnoDB引擎中，我们可以在备份时**加上参数** –single-transaction 参数**来完成不加锁的一致性数据备份**。加上这个参数，在MySQL InnoDB数据引擎的底层，它实际上是通过快照读来实现的。

```sql
mysqldump --single-transaction -uroot -p123456 itcast > itcast.sql
```

### 三、表级锁

每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。

对于表级锁，主要分为以下三类：

1. 表锁
2. 元数据锁（meta data lock，MDL）
3. 意向锁

#### 一、表锁

对于表锁，分为两类：

1. 表共享读锁（read lock）
2. 表独占写锁（write lock）

**读锁不会阻塞其他客户端的读，但是会阻塞写。自己客户端写会报错。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。自己读写都没问题。**

语法：

1、加锁：lock tables 表名... read/write;

2、释放锁：unlock tables / 客户端断开连接

#### 二、元数据锁（MDL锁）

MDL加锁过程是系统自动控制，无需显式使用，**在访问一张表的时候会自动加上**。MDL锁主要作用是维护表元数据（元素据可以理解为表结构）的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。**为了避免DML与DDL冲突，保证读写的正确性。**

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

![image-20251219185306416](img/image-20251219185306416.png)

查看元数据锁：

```sql
select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;
```

### 五、意向锁

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用再一行一行检查每行数据是否加锁，使用意向锁来减少表锁的检查。**意向锁的目的是为了快速判断表里是否有记录被加锁**。

如下图所示，在引入意向锁之前，表锁在加锁前需要一行一行检查每行数据是否加了行锁。

![image-20251219190224819](img/image-20251219190224819.png)

引入了意向锁后，线程A在执行update语句时，给要更新的那一行数据加了行锁的同时，也会给整张表加一个意向锁。线程B在加表锁的时候不用再一行一行检查每行数据是否加了行锁了，它只需要判断当前的意向锁的类型是否和自己要加的表锁的类型兼容，如果兼容就直接能把这个表锁加上了，如果不兼容就线程B加行锁就会处于阻塞状态，阻塞到线程A把事务提交，行锁和意向锁释放后，解除阻塞状态，加上表锁。

**加锁方式**：

1、意向共享锁（IS）：由 `select ... lock in share mode` 添加。

与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。

2、意向排他锁（IX）：当执行 `insert、update、delete、select ... for update `这类语句时添加。

与表锁共享锁（read）和表锁排他锁（write）都互斥。

可以通过以下SQL查看意向锁和行锁的加锁情况：

```sql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```



意向锁它的存在主要是为了解决在InnoDB引擎中加的行锁和表锁的冲突问题。
